'''Module contains definitions for model builder class.

A model builder's primary function is to generate python objects from a stream of token:value
pairs. These pairs will generally be the product of a pygments lexer.
'''

__author__ = 'erik'
# imports for base model
import pygments.token as Token
import collections
# imports for StateModelBuilder
import StateModel
import Attributes.AttributeBuilder as AttributeBuilder
from PlantUML_Lexer import TITLE, STATE, SALIAS, SATTR, SSTART, SEND, TSOURCE, TDEST, TATTR

from Utilities.Logger import LogTools
dlog = LogTools('ModelBuilder.log', 'ModelBuilder')
dlog.rootlog.warning('Module initialized')


class ModelBuilder(object):

    # dictionary of {token types: callback functions}
    action_tokens = dict()

    # Text and Error tokens ignored by default
    ignored_tokens = [Token.Text, Token.Error]

    def __init__(self, model_class, *args, **kwargs):
        self.model_class = model_class
        self.model = self.model_class()

        self.q = collections.deque()  # holds tokens,val pairs drawn from the token generator
        # note: deque chosen over list because it's (1) thread-safe, (2) faster in size changes

    def parse(self, token_stream):
        '''Parses lexed data, executing callbck functions as defined in subclass token_dict
        :param: token_stream    token generator as generated by selected pygments lexer
        :returns: self.model_class instance
        '''
        actions_pending = 0

        for token_tup in token_stream:
            # filter out ignored_tokens defined at the class level
            # if token not part of actionable items, merely add it to the queue
            # otherwise take action on first actionable item in queue
            token = token_tup[0]
            if token in self.__class__.ignored_tokens:
                continue
            elif token in self.__class__.action_tokens:
                actions_pending += 1

            self.q.append(token_tup)

            if actions_pending > 1:
                if self.q[0][0] in self.action_tokens:
                    # execute function defined
                    self.action_tokens[self.q[0][0]]()
                    actions_pending -= 1
                else:
                    continue

        # finish processing any remaining actionable tokens
        # once the stream has dried up
        while actions_pending > 0:
            if self.q[0][0] in self.action_tokens:
                self.action_tokens[self.q[0][0]]()
                actions_pending -= 1
            else:
                dlog.rootlog.error("Non actionable token " + self.q.popleft() + " found at end of deque.")

        # deliver populated model
        return self.model


class StateModelBuilder(ModelBuilder):
    '''
    Generates State Models from a token stream.
    '''

    # dictionary used as case/switch statement
    action_tokens = {}

    def __init__(self, *args, **kwargs):

        ModelBuilder.__init__(self, StateModel.StateDiagram)
        self.logger = dlog.MakeChild('StateModelBuilder')

        # dictionary constructor - list of key,value pairs
        update_dict = dict( [
            (TITLE, self.set_default_tag),  # TITLE should always be the tag name of the module under test
            (STATE, self.assign_state),
            (SALIAS, self.lookup_state),
            (SEND, self.end_superstate),
            (TSOURCE, self.assign_trans),
            ] )

        StateModelBuilder.action_tokens.update(update_dict)

        self.superstate_stack = [None]  # stack of nested superstates
        self.state_aliases = {}  # dictionary of {state_alias: state_name}
        self.diagram = self.model  # bind model instance to new name for code clarity

        # set attribute builder only if assigned on instansiation, otherwise leave as NoneType
        self.attr_builder = kwargs.pop('attribute_builder', None)
        if self.attr_builder:
            self.set_attribute_builder(self.attr_builder)

    def set_attribute_builder(self, attribute_builder):
        '''
        Sets an AttributeBuilder instance that creates attribute instances from raw strings
        :param attribute_builder:
        :return:
        '''
        if not isinstance(attribute_builder, AttributeBuilder.AttributeBuilder):
            raise TypeError
        else:
            self.attr_builder = attribute_builder

    def set_default_tag(self):
        '''Sets the diagramid and attribute_builder.default_tag to TITLE'''
        diagram_title = self.q.popleft()[1].lstrip('title ')
        self.diagram.id = diagram_title
        self.attr_builder.set_default_tag(diagram_title)

    def assign_state(self):
        '''All state names are unique and required for assignment.
        Will not double-add states to self.diagram.'''
        state_name = self.q.popleft()[1]
        if self.q[0][0] == SSTART:
            self.start_superstate(state_name)
        else:
            self.diagram.add_state(state_name, parent_state=self.superstate_stack[-1])

        if self.q[0][0] == SATTR:
            self.add_state_attr(state_name, self.q.popleft()[1])

    def lookup_state(self, state_alias):
        return self.diagram.states[state_alias]

    def add_state_attr(self, state_name, attribute_value):
        '''
        Solves for the attribute object instance if attribute builder available, otherwise
        leave as raw string/unicode type.
        In either case the attribute is added to the state's attribute list.
        '''
        self.diagram.add_state_attr(state_name, self.create_attribute_instances(attribute_value))

    def start_superstate(self, state_name):
        self.q.popleft()[1]  # consume delimiter "{"
        self.diagram.add_state(state_name, parent_state=self.superstate_stack[-1])
        self.superstate_stack.append(state_name)

    def end_superstate(self):
        self.q.popleft()[1]  # consume delimiter "}"
        self.superstate_stack.pop(-1)

    def assign_trans(self):
        '''Assigns a transition to the diagram and State.source, State.destination values'''
        source = self.q.popleft()[1]
        # pull destination from token stream
        if self.q[0][0] == TDEST:
            dest = self.q.popleft()[1]
        else:
            dlog.rootlog.error("!ERROR: Transition source " + str(source) + " found without corresponding destination")
            raise AttributeError
        # add transition to graph
        if len(self.q) > 0 and self.q[0][0] == TATTR:
            transition_attribute = self.q.popleft()[1]
            self.diagram.add_transition(source, dest, parent_state=self.superstate_stack[-1],
                                        attributes=self.create_attribute_instances(transition_attribute))
        else:
            self.diagram.add_transition(source, dest, parent_state=self.superstate_stack[-1])

    def create_attribute_instances(self, raw_value):
        '''
        Create an AttributeType instance if attribute builder is assigned to this StateModelBuilder instance
        :param attribute_string:
        :return:
        '''

        if self.attr_builder and type(raw_value) in [str, unicode]:
            attribute_value = self.attr_builder.solve_attribute(raw_value)
            if isinstance(attribute_value, AttributeBuilder.Attribute_Base):
                self.logger.debug("Added attribute instance %s, as %s", attribute_value, type(attribute_value))
            # return raw string if no attribute value match
            # (will be empty list from attr_builder.solver_attribute)
            elif not attribute_value:
                self.logger.warning("No attribute instance created for %s", raw_value)
                attribute_value = raw_value

        return attribute_value


def build_state_diagram(fpath, attribute_builder=None, preprocess=True):
    '''
    Returns a state diagram lexed from the given plantUML model
    :param fpath: path to state diagram *.puml file
    :param preprocess: run plantUML preprocessor on diagram
    :param attribute_builder: attribute builder instance for defining attribute logic
    :return: StateModel.StateDiagram
    '''
    from PlantUML_Lexer import get_tokens_from_file

    tkns = get_tokens_from_file(fpath, preprocess=preprocess)
    builder = StateModelBuilder(attribute_builder=attribute_builder)
    diagram = builder.parse(tkns)

    dlog.rootlog.info("New diagram parsed from ", fpath)
    dlog.rootlog.info("Parsed " + str(len(diagram.state_names.values())) + "states")
    dlog.rootlog.info("Parsed " + str(len(diagram.get_transitions())) + "transitions")

    return diagram


if __name__ == "__main__":
    import config, os
    from pprint import pprint as pp

    config.sys_utils.set_pp_on()
    dlog.Output2Stdout(level='warning')

    # define input path to diagram
    input_path = os.path.join(config.specs_path, 'EM', 'S_EMC_PRESS_CND.puml')

    # create attribute builder instance for solving attributes
    abuilder = AttributeBuilder.create_attribute_builder(server_ip='127.0.0.1', server_port=5489)

    # ==Build diagram, preprocessor optional==:
    diagram = build_state_diagram(input_path, attribute_builder=abuilder, preprocess=True)

    print "Parsed", len(diagram.state_names.values()), "states"
    print "Parsed", len(diagram.get_transitions()), "transitions"

    print "Attributes generated:"
    pp(diagram.collect_attributes())
    print "=================== Testing Complete ==================="